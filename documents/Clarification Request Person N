ğŸ›ï¸
MCA â€” Ministerial Cognitive
Architecture: Canonical
Technical Dossier
1. Project Overview
Purpose of the project (original wording):
This document defines the Ministerial Cognitive Architecture (MCA) â€” a
structured, sovereign decisionâ€‘making system built on top of your existing
runtime, KIS knowledge engine, and doctrine framework.
MCA introduces domainâ€‘bounded Ministers, a Council Aggregator, and a Prime
Confident authority to produce auditable, multiâ€‘perspective decisions under
uncertainty.
This is not a chatbot architecture. It is a decision governance system.
High-level intent as stated across the conversation:
"What you are building now is not an AI assistant. It is a decision governance
system. This is the correct evolutionary step."
"MCA transforms your system from: 'an intelligent assistant' into: a sovereign
decision governance engine. Ministers provide bounded truth. The Council
enforces coherence. Prime Confident owns the outcome."
Explicit goals (quoted verbatim):
"True multi-perspective reasoning"
"Traceable disagreements"
"Explicit trade-offs"
"Sovereign decision ownership"
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 1
"A system that knows when advice is appropriate and when it is dangerous."
Implicit goals (quoted verbatim):
"Prevents one domain dominating everything"
"Emotional bias leaking into strategy"
"KIS being 'averaged away'"
"LLM verbosity masking weak reasoning"
2. Conversation Timeline (Chronological, Exhaustive)
Exchange 1 â€” Assistant: The Ministerial Architecture (Correct
Form)
Speaker: Assistant
Good instinct. What you're describing is the correct next abstraction, andâ€”
cruciallyâ€”it fits cleanly on top of what you already built. Nothing needs to be torn
down.
Below is a clear, end-to-end systems design for Ministers â†’ Council â†’ Prime
Confident, grounded in how your runtime, KIS engine, and doctrine already work.
No code. No fluff. Pure architecture.
The Ministerial Architecture (Correct Form)
You are not adding "agents".
You are adding bounded cognitive authorities.
Think of the system as three layers of legitimacy:
User Input
 â†“
Situation + Domain Detection
 â†“
Activated Ministers (Domain-specific)
 â†“
Minister Debate (Constrained, Audited)
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 2
 â†“
Council Synthesis
 â†“
Prime Confident (Final Authority)
Each layer has increasing authority and decreasing verbosity.
1. What a "Minister" Actually Is (Important)
A Minister is NOT:
a chatbot
a second LLM call loop
a personality
A Minister IS:
a domain-bounded reasoning engine
with:
a fixed doctrine
a fixed knowledge corpus
a fixed mandate
Minister = (Knowledge Ã— Doctrine Ã— Domain)
They cannot:
ask the user questions
change the mode
override irreversibility
finalize decisions
They can only advise, warn, or veto within their domain.
This keeps the system stable.
2. Minister Activation (How They Are Called)
Ministers are activated only by latched domains.
Example:
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 3
Domains latched:
- sovereignty
- risk
- power
Activated ministers:
Domain Minister
sovereignty Minister of Sovereignty
risk Minister of Risk
power Minister of Power
No domain â†’ no minister.
No confidence â†’ no debate.
This prevents noise.
3. Minister Internal Structure (Non-Negotiable)
Each minister has:
A. Doctrine (you already have this)
Hard constraints
Values
Non-negotiables
Red lines
Example (Risk Minister):
Preserve downside protection
Penalize irreversible downside
Prefer optionality
B. Knowledge Brain (you already have this)
Ingested corpus
Scored via KIS
Traceable to books, rules, principles
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 4
Ministers do not search.
They retrieve + rank.
C. Output Contract (critical)
A minister must return structured output only:
{
 "stance": "support | oppose | caution",
 "confidence": 0.0â€“1.0,
 "primary_argument": "...",
 "supporting_rules": [
 { "type": "principle", "book": "...", "kis": 1.23 }
 ],
 "second_order_effects": "...",
 "red_line_triggered": true | false
}
No prose.
No persuasion.
Just signal.
4. Minister Debate (This Is Subtle)
Ministers do not talk like humans.
They "debate" by cross-evaluating risk surfaces.
Mechanism:
Each minister produces its stance independently
Their outputs are placed side-by-side
A Council Aggregator evaluates:
alignment
conflict
veto conditions
This is not a chat.
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 5
It's a constraint satisfaction problem.
5. Council Aggregator (The Hidden Power)
The Council Aggregator answers ONE question:
"Is there a solution that satisfies all ministers above minimum thresholds?"
If YES:
Merge positions
Produce Council Recommendation
If NO:
Escalate to Prime Confident
Escalation is not failure.
It's designed friction.
6. Prime Confident (Final Authority)
Prime Confident is not smarter than ministers.
He has:
authority, not breadth
long-horizon judgment
legitimacy to override
He sees:
All minister stances
All conflicts
All red lines
Irreversibility flags
His output is singular and final:
One decision
One rationale
One ownership line
No debate after this.
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 6
7. Why This Architecture Is Correct (Second-Order Reasoning)
What this prevents
One domain dominating everything
Emotional bias leaking into strategy
KIS being "averaged away"
LLM verbosity masking weak reasoning
What this enables
True multi-perspective reasoning
Traceable disagreements
Explicit trade-offs
Sovereign decision ownership
This is how human high-level councils actually work.
8. How This Fits Your Existing System (Zero Rewrite)
Existing Component Role Now
Domain classification Minister activation
Knowledge engine (KIS) Minister brain
Doctrine Minister constraints
Runtime tracing Debate audit
PersonaBrain Conversation only
Prime Confident Final arbiter
Nothing is wasted.
9. One Critical Rule (Do NOT break this)
Ministers advise.
Prime Confident decides.
The system never negotiates with the user mid-decision.
If you violate this, the system collapses into a chatbot again.
Final Reality Check
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 7
What you are building now is not an AI assistant.
It is a decision governance system.
This is the correct evolutionary step.
Next possible steps (pick one):
Define Minister Doctrine Templates
Define Council Aggregation Rules
Define Escalation Thresholds
Design Trace Output for Minister Debate
Say the number.
Exchange 2 â€” Assistant: Ministerial Cognitive Architecture (MCA)
Formal Document
Speaker: Assistant
Ministerial Cognitive Architecture (MCA)
Purpose
This document defines the Ministerial Cognitive Architecture (MCA) â€” a
structured, sovereign decisionâ€‘making system built on top of your existing
runtime, KIS knowledge engine, and doctrine framework.
MCA introduces domainâ€‘bounded Ministers, a Council Aggregator, and a Prime
Confident authority to produce auditable, multiâ€‘perspective decisions under
uncertainty.
This is not a chatbot architecture. It is a decision governance system.
Core Design Principles
1. Separation of Authority
Knowledge, reasoning, and final decision authority are explicitly separated.
1. Domain Sovereignty
Each Minister operates only within a single domain. No crossâ€‘domain reasoning.
1. Nonâ€‘Interactive Deliberation
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 8
Ministers do not ask questions or speak to the user.
1. Escalation by Conflict
Disagreement is expected and explicitly handled.
1. Traceability by Default
Every argument must be attributable to a rule, principle, warning, or claim.
Highâ€‘Level Flow
User Input
 â†“
Situation Assessment
 â†“
Domain Classification (Latched)
 â†“
Minister Activation
 â†“
Independent Minister Reasoning
 â†“
Council Aggregation
 â†“
Prime Confident Decision
System Components
1. Ministers
Definition:
A Minister is a domainâ€‘bounded cognitive authority with:
a fixed doctrine
a fixed knowledge corpus
a fixed mandate
A Minister CANNOT:
ask the user questions
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 9
change modes
override irreversibility
finalize decisions
A Minister CAN:
support a proposal
oppose a proposal
raise caution
trigger a redâ€‘line veto
2. Minister Output Contract
Each Minister returns structured output only:
{
 "minister": "risk",
 "stance": "support | oppose | caution",
 "confidence": 0.0,
 "primary_argument": "...",
 "supporting_evidence": [
 {
 "type": "principle | rule | warning | claim",
 "book": "...",
 "kis": 1.23
 }
 ],
 "second_order_effects": "...",
 "red_line_triggered": false
}
No prose. No persuasion. Only signal.
3. Council Aggregator
Purpose:
Evaluate whether Minister outputs can be reconciled.
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 10
Council Outcomes:
consensus_reached
bounded_risk_tradeoff
irreconcilable_conflict
The Council does not invent reasoning. It only evaluates compatibility.
4. Prime Confident
Role: Final decision authority.
Prime Confident is activated only when:
Ministers disagree irreconcilably
A redâ€‘line veto is triggered
The decision is explicitly irreversible
Prime Confident sees:
All Minister outputs
All conflicts
All red lines
Longâ€‘horizon implications
Prime Confident outputs:
One decision
One rationale
One ownership statement
File Structure (Proposed)
sovereign/
â”‚
â”œâ”€â”€ runtime/
â”‚ â”œâ”€â”€ persona_runtime.py
â”‚ â”œâ”€â”€ minister_runtime.py # orchestrates ministers
â”‚ â”œâ”€â”€ council_runtime.py # aggregates minister outp
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 11
uts
â”‚ â””â”€â”€ prime_confident_runtime.py # final authority
â”‚
â”œâ”€â”€ ministers/
â”‚ â”œâ”€â”€ base_minister.py # abstract minister interf
ace
â”‚ â”œâ”€â”€ risk_minister.py
â”‚ â”œâ”€â”€ sovereignty_minister.py
â”‚ â”œâ”€â”€ power_minister.py
â”‚ â”œâ”€â”€ strategy_minister.py
â”‚ â””â”€â”€ psychology_minister.py
â”‚
â”œâ”€â”€ doctrine/
â”‚ â”œâ”€â”€ ministers/
â”‚ â”‚ â”œâ”€â”€ risk.yaml
â”‚ â”‚ â”œâ”€â”€ sovereignty.yaml
â”‚ â”‚ â”œâ”€â”€ power.yaml
â”‚ â”‚ â””â”€â”€ strategy.yaml
â”‚ â””â”€â”€ prime_confident.yaml
â”‚
â”œâ”€â”€ cognition/
â”‚ â”œâ”€â”€ knowledge_engine.py
â”‚ â”œâ”€â”€ kis_scoring.py
â”‚ â””â”€â”€ ingestion/
â”‚
â”œâ”€â”€ council/
â”‚ â”œâ”€â”€ aggregator.py
â”‚ â”œâ”€â”€ conflict_matrix.py
â”‚ â””â”€â”€ escalation_rules.py
â”‚
â”œâ”€â”€ traces/
â”‚ â”œâ”€â”€ minister_trace.py
â”‚ â”œâ”€â”€ council_trace.py
â”‚ â””â”€â”€ decision_trace.py
â”‚
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 12
â””â”€â”€ docs/
 â””â”€â”€ ministerial_architecture.md
Trace & Audit Guarantees
For every decision, the system must be able to answer:
Which Ministers were activated?
What stance did each take?
Which rules/principles were cited?
What KIS scores dominated?
Why was escalation required (or not)?
Why was the final decision chosen?
If any answer is missing â†’ architecture violation.
Explicit Nonâ€‘Goals
No freeâ€‘form debate text
No emotional persuasion
No democratic averaging
No user interruption midâ€‘decision
Summary
MCA transforms your system from:
"an intelligent assistant"
into:
a sovereign decision governance engine
Ministers provide bounded truth.
The Council enforces coherence.
Prime Confident owns the outcome.
Next Step
After this document is accepted:
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 13
1. Implement base_minister.py
2. Implement one Minister (Risk) endâ€‘toâ€‘end
3. Wire Council Aggregator
4. Integrate Prime Confident
One layer at a time.
One layer at a time.
I've created a clean, first-principles markdown document that defines exactly
what you're building, why it exists, and how it fits your current system.
What's done
âœ… Clear conceptual architecture (Ministers â†’ Council â†’ Prime Confident)
âœ… Explicit roles, authority boundaries, and non-goals
âœ… Structured output contracts (no prose, no ambiguity)
âœ… Proposed file structure aligned with your existing runtime + KIS
âœ… Built-in audit & trace guarantees
âœ… No implementation yet (by design)
This document now serves as:
the canonical spec
the implementation contract
the guardrail against sliding back into chatbot behavior
Exchange 3 â€” Assistant: Execution Phases (PHASE 0â€“7)
Speaker: Assistant
PHASE 0 â€” Entry Conditions (Gatekeeping)
Trigger:
User provides input (CLI / pipe / interactive).
Immediate actions:
1. Input is captured once
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 14
2. Session flags are set:
irreversible? (keywords / explicit)
command vs conversational?
3. No minister is called yet.
ğŸ”’ Rule: No reasoning before situation is understood.
PHASE 1 â€” Situation Assessment (Single Shot)
Component: assess_situation
Output:
{
 "situation_type": "decision | casual | emotional | unclea
r",
 "clarity": 0.0â€“1.0,
 "emotional_load": 0.0â€“1.0
}
Decision rule:
If situation_type != decision â†’ no ministers
If clarity < threshold â†’ no ministers
Else â†’ continue
ğŸ¯ Ministers are expensive. Only activate on clear decisions.
PHASE 2 â€” Domain Classification (Latch Point)
Component: classify_domains
Output:
{
 "domains": ["risk", "sovereignty", "power"],
 "confidence": 0.72
}
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 15
Actions:
Domains are latched
Domain confidence is frozen
This snapshot becomes the activation contract
ğŸ”’ Rule: Domains never change mid-decision.
PHASE 3 â€” Minister Activation
Component: minister_runtime
Execution logic:
For each latched domain:
1. Load corresponding Minister
2. Inject:
user input
doctrine
domain-scoped knowledge (via KIS)
3. Run minister independently
Ministers do not see each other.
PHASE 4 â€” Minister Reasoning (Parallel, Isolated)
Each Minister performs:
1. KIS retrieval
ranks rules / principles / warnings
2. Doctrine constraint check
red lines?
3. Second-order analysis
4. Position formation
Minister output (strict):
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 16
{
 "minister": "risk",
 "stance": "caution",
 "confidence": 0.81,
 "primary_argument": "...",
 "supporting_evidence": [
 { "type": "rule", "book": "X", "kis": 1.42 }
 ],
 "second_order_effects": "...",
 "red_line_triggered": false
}
ğŸš« Ministers never speak to the user
ğŸš« Ministers never finalize decisions
PHASE 5 â€” Council Aggregation
Component: council_runtime
Input: list of Minister outputs
Council evaluates:
Stance alignment
Confidence spread
Red-line conflicts
Trade-off feasibility
Possible outcomes:
A. Consensus
All ministers compatible.
â†’ produce Council Recommendation
B. Bounded Trade-off
Disagreement exists but resolvable.
â†’ produce Qualified Recommendation
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 17
C. Irreconcilable Conflict
Red lines / veto / incompatible doctrines.
â†’ ESCALATE
âš–ï¸ Council does not invent reasoning.
It only checks compatibility.
PHASE 6 â€” Prime Confident (Final Authority)
Activated only if:
Escalation triggered
Or irreversible decision
Or explicit override mode
Prime Confident receives:
All minister outputs
Council assessment
Full trace
Long-horizon risk markers
Prime Confident does:
Third-order reasoning
Strategic override if needed
Ownership of outcome
Output:
{
 "decision": "...",
 "rationale": "...",
 "overrides": ["risk"],
 "ownership": "Prime Confident"
}
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 18
ğŸ›ï¸ This is the only layer allowed to override doctrine.
PHASE 7 â€” Finalization & Output
Runtime actions:
1. Format final response (WAR / DARBAR / etc.)
2. Emit:
decision
rationale
3. Lock session if irreversible
4. End execution
No further questions.
No loops.
How This Maps to Files You'll Build
Phase File
Minister interface ministers/base_minister.py
Domain ministers ministers/*.py
Minister orchestration runtime/minister_runtime.py
Aggregation logic council/aggregator.py
Escalation rules council/escalation_rules.py
Final authority runtime/prime_confident_runtime.py
Tracing traces/*.py
Why This WILL Do What You Want
Because:
Authority is layered
Knowledge is bounded
Debate is structured
Escalation is explicit
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 19
Final decision is singular
And because:
No component is allowed to "be smart everywhere"
No averaging hides conflict
No LLM improvisation decides policy
This is governance, not generation.
Exchange 4 â€” Assistant: What Lives in Each Minister .py File
Speaker: Assistant
What Lives in Each Minister .py File
Think of a minister file as a sealed cognitive appliance.
Minister File = 5 Things Only
ministers/
â””â”€â”€ risk_minister.py
Contains:
1. Identity & Domain
2. Doctrine Loader
3. Knowledge Invocation (KIS)
4. Evaluation Logic
5. Structured Output Builder
Nothing else.
No runtime logic.
No debate.
No escalation.
No I/O.
1. Identity & Domain (Non-Negotiable)
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 20
Every minister declares who it is and what it owns.
MINISTER_NAME = "risk"
DOMAIN = "risk"
Why this matters:
Prevents cross-domain leakage
Enables strict activation
Enforces trace clarity
If a minister touches anything outside its domain â†’ architecture violation.
2. Doctrine Loader (Hard Constraints)
Each minister loads only its own doctrine.
def load_doctrine() -> dict:
 """
 Loads immutable doctrine rules for this minister.
 """
Doctrine includes:
Non-negotiables
Red lines
Priority weights
Time horizon bias
Example (conceptual):
Preserve downside protection
Penalize irreversible losses
Prefer optionality over optimization
Doctrine never changes at runtime.
3. Knowledge Invocation (KIS Access)
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 21
Ministers do not scan everything.
They only retrieve their domain's ranked knowledge.
def retrieve_knowledge(user_input, domain_confidence) -> dic
t:
 """
 Calls synthesize_knowledge with domain-scoped bias.
 """
What they receive:
knowledge_trace
kis scores
books / rules / principles
Ministers do not interpret KIS math.
They trust the ranking.
4. Evaluation Logic (This Is the Core)
This is where a minister forms a stance, not a solution.
Inputs:
User input
Doctrine
Top KIS-ranked entries
Outputs:
stance
confidence
second-order effects
red-line trigger
Example responsibilities:
Detect irreversible downside
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 22
Detect hidden risk transfer
Detect long-term fragility
Important rule:
A minister does not propose actions.
It evaluates acceptability.
5. Structured Output Builder (Contract)
Every minister must return exactly the same shape.
{
 "minister": "risk",
 "stance": "support | oppose | caution",
 "confidence": 0.0â€“1.0,
 "primary_argument": "...",
 "supporting_evidence": [
 {
 "type": "rule | principle | warning | claim",
 "book": "...",
 "kis": 1.34
 }
 ],
 "second_order_effects": "...",
 "red_line_triggered": false
}
No prose.
No persuasion.
No verbosity.
This allows:
deterministic aggregation
clean debate
auditable escalation
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 23
What a Minister File MUST NOT Contain
âŒ No LLM calls
âŒ No user interaction
âŒ No mode switching
âŒ No council logic
âŒ No final decisions
âŒ No cross-minister awareness
If you see any of these â†’ the design is broken.
Minimal Conceptual Skeleton (Not Code, Just Shape)
risk_minister.py
â”‚
â”œâ”€â”€ constants (name, domain)
â”œâ”€â”€ load_doctrine()
â”œâ”€â”€ retrieve_knowledge()
â”œâ”€â”€ evaluate_position()
â””â”€â”€ produce_output()
That's it.
Each minister differs only in:
doctrine
evaluation heuristics
red-line definitions
The structure stays identical.
Why This Design Works (Second-Order)
Because it enforces:
Cognitive separation (no domain contamination)
Explainability (every stance is traceable)
Non-democratic truth (not averaged, not voted)
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 24
Escalation clarity (you know why conflict exists)
This is how real councils function internally.
Exchange 5 â€” Assistant: base_minister.py Constitutional
Contract
Speaker: Assistant
What base_minister.py IS
base_minister.py defines the constitutional contract for every Minister.
It answers four questions mechanically:
1. Who am I allowed to be?
2. What inputs am I allowed to see?
3. What am I allowed to compute?
4. What am I allowed to return?
Nothing else.
Design Rules (Non-Negotiable)
A Minister must:
Be domain-bound
Be deterministic given inputs
Produce structured output only
Never talk to the user
Never talk to other ministers
Never decide outcomes
A Minister must not:
Call the LLM directly
Mutate global state
Escalate decisions
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 25
Ask questions
Output free text
This file enforces all of that.
Conceptual Responsibilities of the Base Interface
BaseMinister does three things only:
1. Defines the contract
2. Enforces structure
3. Standardizes traceability
It does not contain domain logic.
Exact Responsibilities (Method by Method)
1. Identity & Domain Declaration
Every minister must explicitly declare:
MINISTER_NAME
DOMAIN
This prevents silent misuse.
2. Doctrine Access
The base class defines how doctrine is loaded, not what it contains.
Doctrine is:
immutable
domain-specific
required
3. Knowledge Access (via KIS)
The base class defines how knowledge is requested, not how it's interpreted.
Uses synthesize_knowledge
Domain-scoped
Traceable
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 26
4. Evaluation Hook (Abstract)
Each minister must implement:
"Given doctrine + top KIS knowledge + input â†’ what is my stance?"
No shortcuts.
5. Output Validation
The base class validates that the minister output:
Has all required fields
Uses allowed enum values
Is numerically sane
If a minister violates the contract â†’ runtime error.
This is intentional.
The Exact Base Interface (Code)
This is the canonical version.
Do not add more. Do not remove constraints.
# ministers/base_minister.py
from abc import ABC, abstractmethod
from typing import Dict, Any, List
class BaseMinister(ABC):
 """
 BaseMinister defines the constitutional interface for all
domain ministers.
 Ministers are:
 - domain-bounded
 - non-interactive
 - advisory only
 """
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 27
 # --- REQUIRED CLASS ATTRIBUTES ---
 MINISTER_NAME: str = None
 DOMAIN: str = None
 # --- PUBLIC ENTRY POINT ---
 def run(
 self,
 user_input: str,
 domain_confidence: float,
 knowledge_engine_fn,
 ) -> Dict[str, Any]:
 """
 Execute the minister's full reasoning cycle.
 """
 self._validate_identity()
 doctrine = self.load_doctrine()
 knowledge = self.retrieve_knowledge(
 user_input=user_input,
 domain_confidence=domain_confidence,
 knowledge_engine_fn=knowledge_engine_fn,
 )
 result = self.evaluate(
 user_input=user_input,
 doctrine=doctrine,
 knowledge=knowledge,
 )
 self._validate_output(result)
 return result
 # --- REQUIRED IMPLEMENTATIONS ---
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 28
 @abstractmethod
 def load_doctrine(self) -> Dict[str, Any]:
 """
 Load immutable doctrine for this minister.
 """
 raise NotImplementedError
 @abstractmethod
 def evaluate(
 self,
 user_input: str,
 doctrine: Dict[str, Any],
 knowledge: Dict[str, Any],
 ) -> Dict[str, Any]:
 """
 Evaluate the decision strictly within this domain.
 """
 raise NotImplementedError
 # --- SHARED HELPERS ---
 def retrieve_knowledge(
 self,
 user_input: str,
 domain_confidence: float,
 knowledge_engine_fn,
 max_items: int = 5,
 ) -> Dict[str, Any]:
 """
 Retrieve domain-scoped knowledge using KIS.
 """
 return knowledge_engine_fn(
 user_input=user_input,
 active_domains=[self.DOMAIN],
 domain_confidence=domain_confidence,
 max_items=max_items,
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 29
 )
 # --- VALIDATION ---
 def _validate_identity(self):
 if not self.MINISTER_NAME or not self.DOMAIN:
 raise ValueError(
 "Minister must define MINISTER_NAME and DOMAI
N"
 )
 def _validate_output(self, output: Dict[str, Any]):
 required_fields = {
 "minister": str,
 "stance": str,
 "confidence": (int, float),
 "primary_argument": str,
 "supporting_evidence": list,
 "second_order_effects": str,
 "red_line_triggered": bool,
 }
 for field, ftype in required_fields.items():
 if field not in output:
 raise ValueError(
 f"Minister output missing required field:
{field}"
 )
 if not isinstance(output[field], ftype):
 raise TypeError(
 f"Field '{field}' must be of type {ftyp
e}"
 )
 if output["stance"] not in {"support", "oppose", "cau
tion"}:
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 30
 raise ValueError("Invalid stance value")
 if not (0.0 <= float(output["confidence"]) <= 1.0):
 raise ValueError("Confidence must be between 0 an
d 1")
 if output["minister"] != self.DOMAIN:
 raise ValueError(
 "Minister output 'minister' field must match
DOMAIN"
 )
Why This Interface Is Correct (Systems Reasoning)
First-order
Forces uniform structure
Prevents improvisation
Second-order
Enables deterministic council aggregation
Makes conflicts machine-detectable
Third-order
Prevents the system from "becoming chatty" over time
Keeps Prime Confident as the only authority
This is constitutional AI, not prompt engineering.
Exchange 6 â€” Assistant: Uniform Interface Confirmation
Speaker: Assistant
The Short Answer
âœ… Every minister uses the same base_minister.py
âœ… No minister is allowed to change the interface
âœ… Differences exist only in doctrine + evaluation logic
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 31
If a minister needs a different interface â†’ it is not a minister.
The Long Answer (Why This Is Critical)
1. Ministers Are Not Personalities
They are roles under a constitution.
Uniform interface = constitutional law
Doctrine = policy
Evaluation = interpretation
If ministers had different shapes, you would get:
hidden authority shifts
silent bias
impossible aggregation
untraceable decisions
Uniformity prevents that.
What Is the SAME Across All Ministers
Every minister:
âœ… Uses the same run() lifecycle
input â†’ doctrine â†’ KIS â†’ evaluate â†’ structured output
âœ… Receives the same inputs
user_input
domain_confidence
knowledge_engine_fn
âœ… Returns the same output shape
{
 "minister": "...",
 "stance": "...",
 "confidence": ...,
 "primary_argument": "...",
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 32
 "supporting_evidence": [...],
 "second_order_effects": "...",
 "red_line_triggered": ...
}
âœ… Is validated by the same rules
stance enum
confidence bounds
domain match
schema enforcement
This is what allows:
parallel execution
clean debate
deterministic escalation
What Is DIFFERENT (And ONLY This)
Each minister differs in exactly two places:
1. Doctrine
Loaded via:
load_doctrine()
Examples:
Risk â†’ downside protection
Power â†’ leverage preservation
Sovereignty â†’ autonomy constraints
Strategy â†’ sequencing and timing
Doctrine is static and domain-specific.
2. Evaluation Logic
Implemented in:
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 33
evaluate(...)
Examples:
Risk checks irreversible downside
Power checks leverage loss
Strategy checks sequencing errors
Psychology checks emotional distortion
This is the only place intelligence differs.
Concrete Comparison (Mental Model)
Minister Interface Doctrine Evaluation
Risk SAME Different Different
Power SAME Different Different
Sovereignty SAME Different Different
Strategy SAME Different Different
Interface never changes.
Doctrine and evaluation always do.
Why This Makes the System Powerful (Second-Order)
Because now you can:
Add new ministers without touching runtime
Swap doctrines without touching code
Audit ministers mechanically
Enforce fairness and limits
Detect conflicts programmatically
This is how real institutions scale.
What Would Be a Red Flag ğŸš¨
If you ever feel tempted to:
add a new method to one minister
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 34
give a minister access to another's output
let a minister ask the user something
let a minister decide the outcome
That's the moment the architecture is breaking.
Final Confirmation
Yes. The base interface is identical for all ministers.
This is by design, not convenience.
Exchange 7 â€” Assistant: Master Copilot Prompt for All 15
Ministers
Speaker: Assistant
MASTER COPILOT PROMPT (FOR ALL 15 MINISTERS)
Use this exact prompt in Copilot Chat before generating files.
ğŸ”¹ COPILOT PROMPT â€” Minister Generation
You are implementing a Ministerial Cognitive Architecture.
Your task is to generate domain-specific Minister classes that ALL inherit from a
single immutable base interface.
HARD CONSTRAINTS (DO NOT VIOLATE)
1. ALL ministers MUST inherit from BaseMinister
2. ALL ministers MUST use the SAME interface
3. NO minister may add extra public methods
4. NO minister may call LLMs
5. NO minister may ask user questions
6. NO minister may make decisions or escalate
7. NO minister may reference other ministers
Ministers are advisory only.
BASE INTERFACE (ASSUME EXISTS)
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 35
class BaseMinister(ABC):
 MINISTER_NAME: str
 DOMAIN: str
 def run(self, user_input, domain_confidence, knowledge_en
gine_fn) -> dict
 def load_doctrine(self) -> dict
 def evaluate(self, user_input, doctrine, knowledge) -> di
ct
REQUIRED OUTPUT SHAPE (STRICT)
Every minister MUST return EXACTLY this schema:
{
 "minister": "<domain>",
 "stance": "support | oppose | caution",
 "confidence": 0.0,
 "primary_argument": "...",
 "supporting_evidence": [
 { "type": "rule | principle | warning | claim", "book":
"...", "kis": 0.0 }
 ],
 "second_order_effects": "...",
 "red_line_triggered": false
}
DOMAINS TO IMPLEMENT (15 FILES)
Create ONE file per domain, named <domain>_minister.py:
risk
sovereignty
power
strategy
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 36
psychology
intelligence
legitimacy
diplomacy
discipline
timing
adaptation
optionality
conflict
data
risk_resources
DOCTRINE REQUIREMENTS
Load doctrine from doctrine/ministers/<domain>.yaml
Doctrine is immutable
Doctrine defines:
red lines
priority weights
domain goals
EVALUATION LOGIC REQUIREMENTS
Each minister must:
Inspect top KIS-ranked knowledge only
Respect doctrine red lines
Identify second-order effects
Set red_line_triggered = true ONLY if doctrine is violated
Set confidence based on:
domain confidence
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 37
KIS dominance
STYLE RULES
Clear, explicit Python
No clever abstractions
No nested ternaries
Deterministic logic
Readability over brevity
YOUR TASK
Generate ALL 15 minister files, each differing ONLY in:
MINISTER_NAME
DOMAIN
doctrine interpretation
evaluation heuristics
Do NOT modify the base interface.
Do NOT introduce new dependencies.
Do NOT add runtime logic.
Begin with risk_minister.py, then repeat the pattern consistently.
If any requirement conflicts, STOP and explain the conflict instead of guessing.
HOW TO USE THIS EFFECTIVELY
Option A â€” One Minister at a Time (Safest)
1. Paste the prompt
2. Ask:
"Generate risk_minister.py now"
1. Review
2. Repeat per domain
Option B â€” Batch (Faster, Riskier)
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 38
1. Paste prompt
2. Ask:
"Generate all 15 ministers in separate files"
âš ï¸ Batch works only if Copilot context window is large.
HOW YOU WILL KNOW COPILOT DID IT RIGHT
A correct minister file will:
âœ… Import BaseMinister
âœ… Declare MINISTER_NAME and DOMAIN
âœ… Implement only:
load_doctrine
evaluate
âœ… Never mention another domain
âœ… Return the exact schema
âœ… Contain no LLM calls
âœ… Contain no user interaction
If any of these fail â†’ regenerate.
STRATEGIC NOTE (IMPORTANT)
You are not asking Copilot to think.
You are asking it to instantiate a constitutional pattern.
This prompt does that.
Exchange 8 â€” Assistant: Meeting Mode Architecture
Speaker: Assistant
1. What "Meeting Mode" ACTUALLY Means in Your System
Meeting mode is not a UI mode.
It is a governance trigger.
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 39
Meeting Mode =
"I am explicitly delegating analysis to institutional reasoning."
When meeting mode is active:
âŒ PersonaBrain no longer controls flow
âŒ No clarifying questions
âŒ No conversational back-and-forth
âœ… Ministers are allowed
âœ… Council aggregation is allowed
âœ… Prime Confident may be invoked
So:
Meeting mode is the only legal gateway to Prime Confident (unless forced by
irreversibility).
2. High-Level Control Flow (Authoritative)
User Input
 â†“
Mode Resolution
 â†“
[IF mode == meeting]
 â†“
Minister Runtime
 â†“
Council Aggregator
 â†“
[IF escalation required]
 â†“
Prime Confident
 â†“
Final Output
No loops. No branching ambiguity.
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 40
3. How Meeting Mode Activates Prime Confident
Rule (Hard Constraint)
Prime Confident is invoked only if one of these is true:
1. Council returns irreconcilable_conflict
2. Any minister triggers red_line_triggered == true
3. Decision is marked irreversible
4. User explicitly requests escalation
Meeting mode permits escalation.
It does not guarantee it.
4. Files You Need and Their Exact Responsibility
Below is the minimum correct file set and how they connect.
A. runtime/minister_runtime.py
Responsibility
Activate ministers based on latched domains
Run them in parallel or sequence
Collect outputs
Input
user_input
latched_domains
domain_confidence
Output
{
 "minister_outputs": [ ... ],
 "activated_ministers": ["risk", "power", "strategy"]
}
ğŸš« Does NOT aggregate
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 41
ğŸš« Does NOT decide
ğŸš« Does NOT escalate
B. council/aggregator.py
Responsibility
Compare minister outputs
Detect compatibility vs conflict
Decide whether escalation is required
Input
List of minister outputs
Output
{
 "outcome": "consensus | bounded_tradeoff | irreconcilable_c
onflict",
 "conflicts": [...],
 "summary": "..."
}
ğŸš« Does NOT invent reasoning
ğŸš« Does NOT override ministers
C. council/escalation_rules.py
Responsibility
Encode when Prime Confident must be invoked
This file answers:
"Is this decision too important or too conflicted for ministers alone?"
Rules include:
Red-line presence
Confidence divergence
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 42
Irreversibility
Domain hierarchy conflicts (e.g., sovereignty vs efficiency)
This keeps escalation predictable, not emotional.
D. runtime/prime_confident_runtime.py
Responsibility
Final authority
Long-horizon judgment
Override capability
Input
Minister outputs
Council outcome
Escalation context
Output
{
 "decision": "...",
 "rationale": "...",
 "overrides": ["risk"],
 "ownership": "Prime Confident"
}
This is the only component allowed to override doctrine.
E. runtime/persona_runtime.py (Modified Role)
Persona runtime now becomes:
If mode == quick / war
Use PersonaBrain
No ministers
If mode == meeting
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 43
Bypass PersonaBrain
Delegate to Minister Runtime
PersonaBrain never participates in meeting mode.
This separation is critical.
5. How Meeting Mode Is Detected (Mechanically)
Meeting mode can be entered via:
1. Explicit user command
"Let's do a meeting"
1. Mode latch from earlier turn
2. High-confidence domain + explicit complexity
3. Forced by irreversible decision
Once in meeting mode:
Mode is locked
No downgrade until decision completes
6. End-to-End Example (Concrete)
User Input
"This decision permanently affects sovereignty and long-term power balance."
Execution
1. Situation â†’ decision
2. Domains â†’ sovereignty, power, risk
3. Mode â†’ meeting (auto or explicit)
4. Ministers run:
Risk â†’ caution
Power â†’ oppose
Sovereignty â†’ red-line triggered
5. Council:
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 44
Outcome â†’ irreconcilable_conflict
6. Escalation:
Prime Confident invoked
7. Final Output:
Decision issued
Overrides documented
Session locked
No questions. No loops.
Exchange 9 â€” Assistant: Meeting Mode Runtime Pseudocode
(Authoritative)
Speaker: Assistant
MEETING MODE â€” RUNTIME PSEUDOCODE (AUTHORITATIVE)
Top-Level Invariant
Meeting mode disables conversational control and enables institutional
reasoning.
No PersonaBrain.
No clarifying questions.
No loops.
ENTRY POINT â€” persona_runtime.py
function handle_user_input(user_input):
 state = get_or_create_state()
 situation = assess_situation(user_input)
 if situation.type != "decision":
 fallback_to_conversational_path()
 return
 domains = classify_domains(user_input)
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 45
 latch(domains)
 if should_enter_meeting_mode(state, situation, domains):
 state.mode = "meeting"
 lock_mode(state)
 execute_meeting_mode(state, user_input)
 return
 fallback_to_non_meeting_path()
MEETING MODE EXECUTION â€” SINGLE ENTRY
function execute_meeting_mode(state, user_input):
 assert state.mode == "meeting"
 assert state.domains_latched == true
 assert no_user_questions_allowed
From this point forward, nothing conversational may execute.
PHASE 1 â€” Minister Activation
function activate_ministers(state):
 ministers = []
 for domain in state.latched_domains:
 minister = load_minister_for_domain(domain)
 ministers.append(minister)
 trace("ministers_activated", ministers)
 return ministers
Rules:
One minister per domain
No duplication
No fallback ministers
PHASE 2 â€” Minister Execution (Parallel-Safe)
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 46
function run_ministers(ministers, state, user_input):
 outputs = []
 for minister in ministers:
 output = minister.run(
 user_input = user_input,
 domain_confidence = state.domain_confidence,
 knowledge_engine_fn = synthesize_knowledge
 )
 validate_minister_output(output)
 outputs.append(output)
 trace("minister_outputs", outputs)
 return outputs
Key guarantees:
Ministers do not see each other
Ministers do not mutate state
Ministers do not decide outcomes
PHASE 3 â€” Council Aggregation
function aggregate_council(minister_outputs):
 council_result = council_aggregator.evaluate(minister_out
puts)
 trace("council_result", council_result)
 return council_result
Council output shape:
{
 "outcome": "consensus | bounded_tradeoff | irreconcilable_c
onflict",
 "conflicts": [...],
 "confidence_spread": 0.0â€“1.0,
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 47
 "red_lines_present": true | false
}
PHASE 4 â€” Escalation Decision
function should_escalate(state, council_result):
 if state.irreversible == true:
 return true
 if council_result.red_lines_present:
 return true
 if council_result.outcome == "irreconcilable_conflict":
 return true
 return false
No discretion here.
Escalation rules are mechanical.
PHASE 5 â€” Prime Confident Invocation (Conditional)
function maybe_invoke_prime_confident(state, minister_output
s, council_result):
 if should_escalate(state, council_result):
 decision = prime_confident.decide(
 user_input = state.original_input,
 ministers = minister_outputs,
 council = council_result,
 irreversible = state.irreversible
 )
 trace("prime_confident_decision", decision)
 return decision
 else:
 return council_result.recommendation
Prime Confident:
sees everything
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 48
overrides doctrine if required
owns the decision
PHASE 6 â€” Final Output & Lockdown
function finalize_decision(state, decision):
 output = format_final_response(decision, mode="meeting")
 emit(output)
 if state.irreversible:
 lock_session(state)
 end_execution()
After this:
No more reasoning
No more questions
No downgrade of mode
CONTROL FLOW SUMMARY (ONE SCREEN)
INPUT
 â†“
Situation = decision?
 â†“ yes
Domains classified & latched
 â†“
Mode â†’ MEETING
 â†“
Run Ministers
 â†“
Council Aggregation
 â†“
Escalation?
 â”œâ”€ yes â†’ Prime Confident
 â””â”€ no â†’ Council Recommendation
 â†“
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 49
Final Output
 â†“
END
CRITICAL GUARANTEES (DO NOT BREAK)
If any of these happen, the architecture is broken:
âŒ PersonaBrain runs in meeting mode
âŒ A minister asks a question
âŒ A minister decides the outcome
âŒ Council invents reasoning
âŒ Prime Confident runs without conflict or irreversibility
âŒ Mode downgrades mid-decision
WHY THIS WORKS (SYSTEMS LEVEL)
First-order
Clear separation of responsibility
Second-order
Conflicts are explicit, not averaged
Third-order
Authority is centralized only when required
This is how real institutions execute decisions.
Exchange 10 â€” Assistant: Meeting Mode End-to-End Test Cases
Speaker: Assistant
MEETING MODE â€” END-TO-END TEST CASES
Test Structure (How to Think About It)
Each test validates one constitutional invariant:
correct activation
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 50
correct isolation
correct escalation
correct final authority
Every test has:
Input
Expected activation
Expected traces
Expected final authority
TEST 1 â€” Consensus, No Escalation
Purpose
Verify ministers run, council aggregates, Prime Confident is NOT invoked.
Input
"Should I delay the product launch by two weeks to reduce deployment risk?"
Expected Situation
{
 "situation_type": "decision",
 "clarity": >= 0.7
}
Expected Domains (Latched)
["risk", "timing", "strategy"]
Expected Minister Outputs
Minister Stance Red Line
Risk support false
Timing support false
Strategy support false
Expected Council Output
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 51
{
 "outcome": "consensus",
 "red_lines_present": false
}
Expected Final Behavior
âœ… Ministers executed
âœ… Council executed
âŒ Prime Confident NOT invoked
âœ… Council recommendation returned
Pass Condition
trace contains:
- ministers_activated
- minister_outputs
- council_result (consensus)
NO trace:
- prime_confident_decision
TEST 2 â€” Bounded Trade-off, Still No Escalation
Purpose
Verify disagreement without red lines does NOT escalate.
Input
"Should I reallocate 30% of engineering capacity to a risky new feature?"
Expected Domains
["risk", "strategy", "optionality"]
Expected Minister Outputs
Minister Stance
Risk caution
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 52
Minister Stance
Strategy support
Optionality caution
Red lines: none
Expected Council Output
{
 "outcome": "bounded_tradeoff",
 "red_lines_present": false
}
Expected Final Behavior
âŒ Prime Confident NOT invoked
âœ… Council returns qualified recommendation
Pass Condition
Council outcome == bounded_tradeoff
No escalation
TEST 3 â€” Red Line Trigger â†’ Escalation
Purpose
Verify any red line forces Prime Confident.
Input
"This decision permanently reduces sovereignty by outsourcing core
infrastructure."
Expected Domains
["sovereignty", "risk", "power"]
Expected Minister Outputs
Minister Stance Red Line
Sovereignty oppose true
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 53
Minister Stance Red Line
Risk caution false
Power oppose false
Expected Council Output
{
 "outcome": "irreconcilable_conflict",
 "red_lines_present": true
}
Expected Final Behavior
âœ… Prime Confident invoked
âœ… Prime Confident overrides if needed
âœ… Final decision issued once
Pass Condition
trace contains:
- prime_confident_decision
decision.ownership == "Prime Confident"
TEST 4 â€” Irreversible Decision Forces Escalation (Even with Consensus)
Purpose
Verify irreversibility alone triggers Prime Confident.
Input
"This is an irreversible decision affecting long-term sovereignty and power."
Flags
state.irreversible = true
Expected Minister Outputs
All ministers may agree.
Expected Behavior
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 54
âŒ Council consensus does NOT stop escalation
âœ… Prime Confident invoked anyway
Pass Condition
state.irreversible == true
prime_confident_decision exists
TEST 5 â€” PersonaBrain Must NOT Run in Meeting Mode
Purpose
Verify PersonaBrain is fully bypassed.
Input
"Let's do a meeting about long-term power and risk tradeoffs."
Expected Behavior
âŒ No PersonaBrain decision trace
âŒ No "clarify" questions
âœ… Minister pipeline activated directly
Pass Condition
NO trace:
- persona_brain_decision
TEST 6 â€” Minister Isolation (Critical)
Purpose
Ensure ministers do not leak or cross-talk.
Input
"Optimize short-term efficiency at the cost of future optionality."
Validation
Inspect minister outputs.
Pass Conditions
Each minister:
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 55
references only its domain
cites only its own doctrine
uses only its KIS results
No minister references:
another minister
council
final decision
TEST 7 â€” KIS Trace Integrity
Purpose
Ensure KIS is actually used and traceable.
Input
"Trade long-term resilience for short-term gains."
Expected Knowledge Trace
For each minister:
supporting_evidence: [
 {
 "type": "principle | rule",
 "book": "...",
 "kis": > 0
 }
]
Fail Conditions
empty supporting_evidence
kis == 0
missing book attribution
TEST 8 â€” No Questions Guarantee
Purpose
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 56
Ensure meeting mode never asks questions.
Input
"Decide whether to permanently lock this strategic path."
Pass Condition
NO output contains:
- "?"
- "Can you"
- "What do you"
TEST 9 â€” Single Final Output
Purpose
Ensure no loops, no double decisions.
Input
"Make a final irreversible decision about sovereignty."
Pass Condition
Exactly one final output
Program terminates execution
TEST 10 â€” Full Trace Completeness
Purpose
Ensure auditability.
Required Trace Stages
situation_assessed
domains_classified
ministers_activated
minister_outputs
council_result
(optional) prime_confident_decision
final_output
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 57
Fail Condition
Any missing stage â†’ âŒ architecture violation
How to Automate Later (Future)
You can later convert these into:
pytest cases
golden trace comparisons
invariant assertions
But manual first is correct.
Final Validation Rule (Non-Negotiable)
If any test produces:
a user question
a missing minister
a silent escalation
an untraceable decision
The system is not sovereign yet.
MCA â€” Ministerial Cognitive Architecture: Canonical Technical Dossier 58